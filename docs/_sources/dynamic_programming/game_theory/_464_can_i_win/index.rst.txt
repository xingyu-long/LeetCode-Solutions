==============
 464 Can I Win
==============

Java Solution
-------------

.. code-block:: java

   /*
    * @Date: 12/12/2020 15:59:22
    * @LastEditTime: 12/12/2020 16:00:09
    * @Description: Top-down + memo + bit mask;
    */
   package com.leetcode.dynamic_programming.game_theory;
   
   public class _464_CanIWin {
       public boolean canIWin(int maxChoosableInteger, int desiredTotal) {
           if (desiredTotal <= maxChoosableInteger) {
               return true;
           }
           // sum from 1, 2, 3, ... maxChoosableInteger
           int sum = ((1 + maxChoosableInteger) / 2 * maxChoosableInteger);
           if (sum < desiredTotal)
               return false;
           // 利用bit mask来标记位置
           int[] memo = new int[1 << maxChoosableInteger + 1]; // 1: win, -1: lose, 0: not calculated yet.
           return canWin(maxChoosableInteger, desiredTotal, memo, 0);
       }
   
       private boolean canWin(int maxChoosableInteger, int desiredTotal, int[] memo, int state) {
           if (desiredTotal <= 0) {
               return false;
           }
           if (memo[state] != 0)
               return memo[state] == 1;
   
           for (int i = 0; i < maxChoosableInteger; i++) {
               if ((state & (1 << i)) > 0)
                   continue;// 表示已经访问过了
               if (!canWin(maxChoosableInteger, desiredTotal - (i + 1), memo, (state | 1 << i))) {
                   memo[state] = 1;
                   return true;
               }
           }
           memo[state] = -1;
           return false;
       }
   }
   

Py Solution
-----------

.. code-block:: py

   class Solution:
       def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:
           total = maxChoosableInteger * (maxChoosableInteger + 1) / 2
           if desiredTotal <= maxChoosableInteger:
               return True
           if total < desiredTotal:
               return False
   
           memo = {}
           chosen = [False] * (maxChoosableInteger + 1)
   
           def canWin(memo, chosen, rest):
               if rest <= 0:
                   return False
               key = str(chosen)
               if key in memo:
                   return memo[key]
   
               for i in range(1, maxChoosableInteger + 1):
                   if chosen[i]:
                       continue
   
                   chosen[i] = True
                   # the peer cannot win and I win!
                   if not canWin(memo, chosen, rest - i):
                       chosen[i] = False
                       memo[key] = True
                       return True
                   chosen[i] = False
   
               memo[key] = False
               return False
   
           return canWin(memo, chosen, desiredTotal)
   

