=========================================
 317 Shortest Distance From All Buildings
=========================================

Java Solution
-------------

.. code-block:: java

   /*
    * @Date: 06/21/2022 10:29:39
    * @LastEditTime: 06/21/2022 10:51:57
    * @Description: BFS, matrix
    */
   package com.leetcode.bfs_and_dfs;
   
   import java.util.LinkedList;
   import java.util.Queue;
   
   public class _317_ShortestDistanceFromAllBuildings {
   
       private int[][] dirs = {{0,1}, {1, 0}, {0, -1}, {-1, 0}};
   
       // time: O(m * n * m * n)
       // space: O(m * n)
       public int shortestDistance(int[][] grid) {
           if (grid == null || grid.length == 0 || grid[0] == null || grid[0].length == 0) {
               return -1;
           }
           int m = grid.length, n = grid[0].length;
           int buildingTotal = 0;
           int[][] reachBuild = new int[m][n]; // from (i, j), how many buildings it can reach.
           int[][] dist = new int[m][n]; // distance for (i, j) to reach all buildings. 
           for (int i = 0; i < m; i++) {
               for (int j = 0; j < n; j++) {
                   if (grid[i][j] == 1) {
                       buildingTotal++;
                       bfs(grid, reachBuild, dist, i, j);
                   }
               }
           }
           int res = Integer.MAX_VALUE;
           for (int i = 0; i < m; i++) {
               for (int j = 0; j < n; j++) {
                   if (grid[i][j] == 0) {
                       if (reachBuild[i][j] == buildingTotal && dist[i][j] < res) {
                           res = dist[i][j];
                       }
                   }
               }
           }
           return res == Integer.MAX_VALUE ? -1 : res;   
       }
   
   
       public void bfs(int[][] grid, int[][] reachBuild, int[][] dist, int x, int y) {
           int m = grid.length, n = grid[0].length;
           boolean[][] visited = new boolean[m][n];
           Queue<int[]> queue = new LinkedList<>();
           queue.offer(new int[]{x, y});
           visited[x][y] = true;
           int level = 1; // use level for distance
           while (!queue.isEmpty()) {
               int size = queue.size();
               for (int i = 0; i < size; i++) {
                   int[] curr = queue.poll();
                   for (int[] dir : dirs) {
                       int newX = curr[0] + dir[0];
                       int newY = curr[1] + dir[1];
                       if (isValid(grid, visited, newX, newY)) {
                           visited[newX][newY] = true;
                           queue.offer(new int[]{newX, newY});
                           dist[newX][newY] += level;
                           reachBuild[newX][newY] += 1;
                       }
                   }
               }
               level += 1; // update the distance
           }
       }
   
   
       public boolean isValid(int[][] grid, boolean[][] visited, int x, int y) {
           if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length) return false;
           if (visited[x][y]) return false;
           if (grid[x][y] != 0) return false;
           return true;
       }
   }
   

Py Solution
-----------

.. code-block:: py

   from collections import deque
   from typing import List
   
   
   class Solution:
       # 从每一个建筑物出发，对于每一个0的位置，我们记录能到建筑的个数reach以及到达各个建筑物的距离dist
       # time: O(M*N*M*N)
       def shortestDistance(self, grid: List[List[int]]) -> int:
           # bfs
           m, n = len(grid), len(grid[0])
           dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]]
           reach = [[0] * n for _ in range(m)]
           dist = [[0] * n for _ in range(m)]
   
           def bfs(x, y):
               visited = set()
               queue = deque()
               queue.append((x, y))
               visited.add((x, y))
               level = 0
               while queue:
                   level += 1
                   size = len(queue)
                   for _ in range(size):
                       curr_x, curr_y = queue.popleft()
                       for d in dirs:
                           new_x, new_y = curr_x + d[0], curr_y + d[1]
                           if new_x >= m or new_x < 0 or new_y >= n or new_y < 0:
                               continue
                           if (new_x, new_y) in visited:
                               continue
                           if grid[new_x][new_y] != 0:
                               continue
                           visited.add((new_x, new_y))
                           queue.append((new_x, new_y))
                           dist[new_x][new_y] += level
                           reach[new_x][new_y] += 1
   
           building_total = 0
           for i in range(m):
               for j in range(n):
                   if grid[i][j] == 1:
                       building_total += 1
                       bfs(i, j)
   
           res = float("inf")
           for i in range(m):
               for j in range(n):
                   if (
                       grid[i][j] == 0
                       and reach[i][j] == building_total
                       and dist[i][j] < res
                   ):
                       res = dist[i][j]
           return -1 if res == float("inf") else res
   

