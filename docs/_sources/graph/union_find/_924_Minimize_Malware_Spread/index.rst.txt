============================
 924 Minimize Malware Spread
============================

Java Solution
-------------

.. code-block:: java

   package com.leetcode.graph.union_find;
   
   import java.util.Arrays;
   
   /**
    * @Date: 10/06/2020
    * @Description: Union Find.
    **/
   public class _924_Minimize_Malware_Spread {
       // 题目理解比较难，就是会尽量减少传播的情况
       // 并且由于指明删除一个有害点，然后我们需要找最大的group并且有害的个数只有1 这样就最小化伤害了。
       static class UF {
           int[] size;
           int[] id;
           int[] affected;
   
           public UF(int n) {
               size = new int[n];
               id = new int[n];
               affected = new int[n];
               for (int i = 0; i < n; i++) {
                   size[i] = 1;
                   id[i] = i;
               }
           }
   
           public int find(int p) {
               while (p != id[p]) {
                   id[p] = id[id[p]];
                   p = id[p];
               }
               return p;
           }
   
           public void union(int p, int q) {
               int rootP = find(p);
               int rootQ = find(q);
               if (rootP == rootQ) return;
               if (size[rootP] > size[rootQ]) {
                   size[rootP] += size[rootQ];
                   id[rootQ] = rootP;
               } else {
                   size[rootQ] += size[rootP];
                   id[rootP] = rootQ;
               }
           }
       }
   
       public int minMalwareSpread(int[][] graph, int[] initial) {
           int n = graph.length;
           UF uf = new UF(n);
           for (int i = 0; i < n; i++) {
               for (int j = 0; j < n; j++) {
                   if (graph[i][j] == 1)
                       uf.union(i, j);
               }
           }
   
           for (int i : initial) {
               int root = uf.find(i);
               uf.affected[root]++;
           }
   
           int num = 0;
           int res = -1;
           Arrays.sort(initial);
           for (int i : initial) {
               int root = uf.find(i);
               // 表明移除这个就不会影响其他的，所以剩下的最多。
               if (uf.affected[root] == 1) {
                   if (num < uf.size[root]) {
                       num = uf.size[root];
                       res = i;
                   }
               }
           }
           return res == -1 ? initial[0] : res;
       }
   }
   

