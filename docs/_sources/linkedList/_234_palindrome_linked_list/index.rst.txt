===========================
 234 Palindrome Linked List
===========================

Java Solution
-------------

.. code-block:: java

   package com.leetcode.linkedList;
   
   import com.leetcode.common.ListNode;
   
   public class _234_PalindromeLinkedList {
   
       /**
        *  234. Palindrome Linked List
        *  When: 2019/05/16
        *  Review1: 2019/7/8
        *  Difficulty: Easy
   
            Input: 1->2
            Output: false
            Input: 1->2->2->1
            Output: true
   
           solution:
           首先找到中间的部分，将其后面的反转，然后一一比较，如果有不同的，那就不是回文数。
        * @param head
        * @return
        */
       // time: O(n) space: O(1)
       public boolean isPalindrome(ListNode head) {
           if (head == null) return true;
           ListNode middle = findMiddle(head);
           middle.next = reverse(middle.next);
   
           ListNode p = head;
           ListNode q = middle.next;
           while (p != null && q != null) {
               if (p.val != q.val) return false;
               p = p.next;
               q = q.next;
           }
           return true;
       }
   
       public ListNode findMiddle(ListNode head) {
           ListNode slow = head;
           ListNode fast = head;
           while (fast.next != null && fast.next.next != null) {
               slow = slow.next;
               fast = fast.next.next;
           }
           return slow;
       }
   
       public ListNode reverse(ListNode head) {
           ListNode pre = null;
           while (head != null) {
               ListNode temp = head.next;
               head.next = pre;
               pre = head;
               head = temp;
           }
           return pre;
       }
   }

Py Solution
-----------

.. code-block:: py

   from typing import Optional
   from leetcode.common.py_utils import ListNode
   
   
   class Solution:
       def isPalindrome(self, head: Optional[ListNode]) -> bool:
   
           def find_middle(head):
               slow = head
               fast = head
               while fast.next and fast.next.next:
                   slow = slow.next
                   fast = fast.next.next
               return slow
   
           def reverse(head):
               dummy = ListNode(next=head)
               prev = dummy
               curr = head
               while curr and curr.next:
                   nxt = curr.next
                   curr.next = nxt.next
                   nxt.next = prev.next
                   prev.next = nxt
               return dummy.next
   
           mid = find_middle(head)
           reverse_head = reverse(mid.next)
           mid.next = None
           p = head
           q = reverse_head
           while p and q:
               if p.val != q.val:
                   return False
               p = p.next
               q = q.next
           return True
   

