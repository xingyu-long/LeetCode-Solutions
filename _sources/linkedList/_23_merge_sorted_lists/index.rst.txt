======================
 23 Merge Sorted Lists
======================

Py Solution
-----------

.. code-block:: py

   from heapq import heappop, heappush
   from typing import List, Optional
   
   from leetcode.common.py_utils import ListNode
   
   
   class Solution:
       # Time: O(M * K * logK), where K <= 10^4 is length of lists, M <= 500 is number of elements each list.
       def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
           # use heap
           ListNode.__lt__ = lambda self, other: self.val < other.val
   
           heap = []
           dummy = ListNode()
           curr = dummy
           for l in lists:
               if l:
                   heappush(heap, l)
           while heap:
               head = heappop(heap)
               curr.next = head
               curr = curr.next
               if head.next:
                   heappush(heap, head.next)
   
           return dummy.next
   
   
   class Solution2:
       def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
   
           def merge(
               list1: Optional[ListNode], list2: Optional[ListNode]
           ) -> Optional[ListNode]:
               if not list1:
                   return list2
               if not list2:
                   return list1
               if list1.val < list2.val:
                   list1.next = merge(list1.next, list2)
                   return list1
               else:
                   list2.next = merge(list1, list2.next)
                   return list2
   
           def sort(lists: Optional[ListNode], start: int, end: int) -> Optional[ListNode]:
               if start > end:
                   return None
               if start == end:
                   return lists[start]
   
               mid = start + (end - start) // 2
               l1 = sort(lists, start, mid)
               l2 = sort(lists, mid + 1, end)
               return merge(l1, l2)
   
           return sort(lists, 0, len(lists) - 1)
   

Java Solution
-------------

.. code-block:: java

   package com.leetcode.linkedList;
   
   import com.leetcode.common.ListNode;
   
   import java.util.PriorityQueue;
   
   public class _23_MergekSortedLists {
       /**
        * 23. Merge k Sorted Lists
        * When:2019/7/7
        * review1:2019/9/2
        * Difficulty: Hard
        *
        * solution:
        * (1) 使用合并排序
        * (2) 使用PriorityQueue （从小到大排序）
        * <p>
        * time : O(nlogk) where k is the number of linked lists
        * space : O(n)
        *
        * @param lists
        * @return
        */
       public ListNode mergeKLists(ListNode[] lists) {
           // 使用PriorityQueue实现
           if (lists == null || lists.length == 0) return null;
           PriorityQueue<ListNode> pq = new PriorityQueue<>(lists.length, (a, b) -> a.val - b.val);
           ListNode dummy = new ListNode(0);
           ListNode cur = dummy;
   
           for (ListNode list : lists) {
               if (list != null) { // 这里需要判断是否为空，防止[[]]这样的情况
                   pq.add(list);
               }
           }
           while (!pq.isEmpty()) {
               //放入到返回结果中
               cur.next = pq.poll();
               cur = cur.next;
               if (cur.next != null) {
                   pq.add(cur.next);
               }
           }
           return dummy.next;
       }
   
       /**
        * 合并排序
        */
       // 另外有一个sort list 需要用ListNode然后找中点
       public ListNode mergeKLists2(ListNode[] lists) {
           if (lists == null || lists.length == 0) return null;
           return sort(lists, 0, lists.length - 1);
       }
   
       public ListNode sort(ListNode[] lists, int lo, int hi) {
           if (lo > hi) return null; // 这里需要注意。
           if (lo == hi) return lists[lo];
           int mid = (hi - lo) / 2 + lo;
           ListNode l1 = sort(lists, lo, mid);
           ListNode l2 = sort(lists, mid + 1, hi);
           return merge(l1, l2);
       }
   
       public ListNode merge(ListNode l1, ListNode l2) {
           if (l1 == null) return l2;
           if (l2 == null) return l1;
           if (l1.val < l2.val) {
               l1.next = merge(l1.next, l2);
               return l1;
           } else {
               l2.next = merge(l1, l2.next);
               return l2;
           }
       }
   }
   

