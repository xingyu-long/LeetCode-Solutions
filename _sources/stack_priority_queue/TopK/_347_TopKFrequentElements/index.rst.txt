=========================
 347 Topkfrequentelements
=========================

Py Solution
-----------

.. code-block:: py

   """
   347. Top K Frequent Elements
   ---
   
   Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.
   ---
   
   Example 1:
   
   Input: nums = [1,1,1,2,2,3], k = 2
   Output: [1,2]
   
   Example 2:
   
   Input: nums = [1], k = 1
   Output: [1]
   ---
   
   topics: heapq, bucket sorting
   """
   
   import heapq
   from typing import List
   from collections import Counter
   
   
   class Solution:
       # heapq
       # time: O(nlogK)
       def topKFrequent(self, nums: List[int], k: int) -> List[int]:
           count = Counter(nums)
           heap = []
           for key, freq in count.items():
               heapq.heappush(heap, (freq, key))
               if len(heap) > k:
                   heapq.heappop(heap)
           return [x[1] for x in heap]
   
   
   class Solution2:
       # bucket sorting
       # time: O(n)
       # space: O(n)
       def topKFrequent(self, nums: List[int], k: int) -> List[int]:
           if not nums:
               return []
           counter = Counter(nums)
           max_freq = max(counter.values()) + 1
           buckets = [[] for _ in range(max_freq)]
           for item, freq in counter.items():
               buckets[freq].append(item)
           res = []
           for i in range(max_freq)[::-1]:
               for item in buckets[i]:
                   if len(res) < k:
                       res.append(item)
                   else:
                       break
           return res
   

Java Solution
-------------

.. code-block:: java

   package com.leetcode.stack_priority_queue.TopK;
   
   import java.util.*;
   
   /**
    * @Date: 05/04/2020
    * @Description: TopK, PQ
    **/
   public class _347_TopKFrequentElements {
       // 利用PriorityQueue
       // 这才是nlogK的算法 维持最多k个
       public int[] topKFrequent(int[] nums, int k) {
           List<Integer> list = new ArrayList<>();
           if (nums == null || nums.length == 0) {
               return new int[]{};
           }
           Map<Integer, Integer> map = new HashMap<>();
           for (int num : nums) {
               map.put(num, map.getOrDefault(num, 0) + 1);
           }
           PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> map.get(a).compareTo(map.get(b)));
           for (int key : map.keySet()) {
               pq.offer(key);
               if (pq.size() > k) {
                   pq.poll();
               }
           }
   
           while (!pq.isEmpty()) {
               list.add(pq.poll());
           }
           int[] res = new int[list.size()];
           for (int i = 0; i < list.size(); i++) {
               res[i] = list.get(list.size() - i - 1);
           }
           return res;
       }
   
       public int[] topKFrequent2(int[] nums, int k) {
           if (nums == null || nums.length == 0) {
               return new int[]{};
           }
           int n = nums.length;
           List<Integer>[] bucket = new List[n + 1];
           Map<Integer, Integer> map = new HashMap<>();
           for (int num : nums) {
               map.put(num, map.getOrDefault(num, 0) + 1);
           }
           for (int num : map.keySet()) {
               int freq = map.get(num);
               if (bucket[freq] == null) {
                   bucket[freq] = new ArrayList<>();
               }
               bucket[freq].add(num);
           }
           int[] res = new int[k];
           int index = 0;
           for (int i = n; i >= 0; i--) {
               if (bucket[i] != null) {
                   for (int j = 0; j < bucket[i].size() && k > 0; j++) {
                       res[index++] = bucket[i].get(j);
                       k--;
                   }
               }
           }
           return res;
       }
   }
   

