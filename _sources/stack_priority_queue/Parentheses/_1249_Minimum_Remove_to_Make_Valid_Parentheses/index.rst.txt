==============================================
 1249 Minimum Remove To Make Valid Parentheses
==============================================

Py Solution
-----------

.. code-block:: py

   '''
   Date: 03/14/2022 18:27:50
   LastEditTime: 03/14/2022 18:27:50
   Description: Parentheses
   '''
   from collections import deque
   
   
   class Solution:
       def minRemoveToMakeValid(self, s: str) -> str:
           stack = deque()
           mismatch = set()
           for i in range(len(s)):
               if s[i] == '(':
                   stack.append(i)
               elif s[i] == ')':
                   if len(stack):
                       stack.pop()  # default pop from top.
                   else:
                       mismatch.add(i)
           for item in list(stack):
               mismatch.add(item)
           res = []
           for i in range(len(s)):
               if i not in mismatch:
                   res.append(s[i])
           return ''.join(res)
   

Java Solution
-------------

.. code-block:: java

   /*
    * @Date: 04/25/2020 10:43:56
    * @LastEditTime: 02/19/2021 08:58:55
    * @Description: Stack
    */
   package com.leetcode.stack_priority_queue.Parentheses;
   
   import java.util.HashSet;
   import java.util.Set;
   import java.util.Stack;
   
   public class _1249_MinimumRemovetoMakeValidParentheses {
   
       // 主要思想还是利用括号匹配来进行，记录mismatched的位置，不加入就可以了
       // 没有想到
       public String minRemoveToMakeValid(String s) {
           // 依然是使用stack来 决定左右括号是否匹配
           Stack<Integer> stack = new Stack<>();
           // 记录mismatch的地方
           Set<Integer> mismatch = new HashSet<>();
   
           for (int i = 0; i < s.length(); i++) {
               char ch = s.charAt(i);
               if (ch == '(') {
                   stack.push(i);
               } else if (ch == ')') {
                   if (stack.isEmpty()) {
                       mismatch.add(i);
                   } else {
                       stack.pop();
                   }
               }
           }
   
           while (!stack.isEmpty()) {
               mismatch.add(stack.pop());
           }
   
           StringBuilder sb = new StringBuilder();
           for (int i = 0; i < s.length(); i++) {
               if (!mismatch.contains(i)) {
                   sb.append(s.charAt(i));
               }
           }
           return sb.toString();
       }
   }
   

