========================
 496 Nextgreaterelementi
========================

Java Solution
-------------

.. code-block:: java

   package com.leetcode.stack_priority_queue.monoStack;
   
   import java.util.HashMap;
   import java.util.Map;
   import java.util.Stack;
   
   /**
    * @Date: 04/15/2020
    * @Description: Mono stack
    **/
   public class _496_NextGreaterElementI {
       public int[] nextGreaterElement(int[] nums1, int[] nums2) {
           HashMap<Integer, Integer> map = new HashMap<>();
           Stack<Integer> stack = new Stack<>();
           for (int num : nums2) {
               while (!stack.isEmpty() && stack.peek() < num) {
                   map.put(stack.pop(), num);
               }
               stack.push(num);
           }
           int[] res = new int[nums1.length];
           for (int i = 0; i < nums1.length; i++) {
               res[i] = map.getOrDefault(nums1[i], -1);
           }
           return res;
       }
   
       // 倒着写
       public int[] nextGreaterElement2(int[] nums1, int[] nums2) {
           Stack<Integer> stack = new Stack<>();
           Map<Integer, Integer> map = new HashMap<>();
           for (int i = nums2.length - 1; i >= 0; i--) {
               while (!stack.isEmpty() && nums2[i] > stack.peek()) {
                   stack.pop();
               }
               if (stack.isEmpty()) map.put(nums2[i], -1);
               else map.put(nums2[i], stack.peek());
               stack.push(nums2[i]);
           }
           int[] res = new int[nums1.length];
           for (int i = 0; i < nums1.length; i++) {
               res[i] = map.get(nums1[i]);
           }
           return res;
       }
   }
   

Py Solution
-----------

.. code-block:: py

   from typing import List
   
   
   class Solution:
       def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
           stack = []
           m = {}
           n = len(nums1)
           for num in nums2:
               while stack and num > stack[-1]:
                   prev = stack.pop()
                   m[prev] = num
               stack.append(num)
   
           return [m[num] if num in m else -1 for num in nums1]
   

