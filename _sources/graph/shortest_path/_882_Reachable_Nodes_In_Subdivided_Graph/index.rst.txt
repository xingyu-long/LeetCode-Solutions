========================================
 882 Reachable Nodes In Subdivided Graph
========================================

Java Solution
-------------

.. code-block:: java

   /*
    * @Date: 09/12/2021 17:37:09
    * @LastEditTime: 09/12/2021 17:39:22
    * @Description: Djistra's Algo
    */
   package com.leetcode.graph.shortest_path;
   
   import java.util.Map;
   import java.util.HashMap;
   import java.util.PriorityQueue;
   
   public class _882_ReachableNodesInSubdividedGraph {
       // 需要再看看
       // https://zxi.mytechroad.com/blog/graph/leetcode-882-reachable-nodes-in-subdivided-graph/
       public int reachableNodes(int[][] edges, int maxMoves, int n) {
           Map<Integer, Map<Integer, Integer>> graph = new HashMap<>();
           // build graph
           for (int[] edge : edges) {
               int u = edge[0], v = edge[1];
               int w = edge[2];
               graph.putIfAbsent(u, new HashMap<>());
               graph.putIfAbsent(v, new HashMap<>());
               graph.get(u).put(v, w);
               graph.get(v).put(u, w);
           }
           // hp, node
           PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (b[0] - a[0]));
           Map<Integer, Integer> HP = new HashMap<>();
           pq.offer(new int[] { maxMoves, 0 });
           while (!pq.isEmpty()) {
               int[] curr = pq.poll();
               int hp = curr[0], node = curr[1];
               // already visited this node.
               if (HP.containsKey(node))
                   continue;
               // 在这里加入，保证每次加入的hp值都是相对最大的（因为第一个被pop出来）
               HP.put(node, hp);
               Map<Integer, Integer> e = graph.get(node);
               if (e == null)
                   continue;
               for (Integer next : e.keySet()) {
                   int nextHP = hp - (e.get(next) + 1);
                   if (HP.containsKey(next) || nextHP < 0)
                       continue;
                   pq.offer(new int[] { nextHP, next });
               }
           }
           int res = HP.size();
           for (int[] edge : edges) {
               // 重叠的情况，也不会超过总的点数
               int u = HP.getOrDefault(edge[0], 0);
               int v = HP.getOrDefault(edge[1], 0);
               res += Math.min(edge[2], u + v);
           }
           return res;
       }
   }
   

Py Solution
-----------

.. code-block:: py

   '''
   Date: 09/12/2021 18:25:12
   LastEditTime: 09/12/2021 18:32:58
   Description: Djistra's Algo
   '''
   from collections import defaultdict
   from typing import List
   import heapq
   
   
   class Solution:
       def reachableNodes(self, edges: List[List[int]], maxMoves: int, n: int) -> int:
           d = defaultdict(dict)
           for u, v, w in edges:
               d[u][v] = d[v][u] = w
           pq = [(-maxMoves, 0)] # 利用负数来达到 max heap的效果
           HP = {}  # node-> hp
           while pq:
               hp, node = heapq.heappop(pq)
               if node not in HP:
                   HP[node] = -hp # 这个还是保持之前的正数
                   for next_node in d[node]:
                       next_hp = -hp - (d[node][next_node] + 1)
                       if next_node not in HP and next_hp >= 0:
                           heapq.heappush(pq, (-next_hp, next_node))
           res = len(HP)
           for u, v, w in edges:
               res += min(HP.get(u, 0) + HP.get(v, 0), w)
           return res
   
   
   s = Solution()
   s.reachableNodes([[0,1,10],[0,2,1],[1,2,2]], 6, 3)

