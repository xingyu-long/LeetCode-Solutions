======================
 97 Interleavingstring
======================

Java Solution
-------------

.. code-block:: java

   package com.leetcode.dynamic_programming;
   
   public class _97_InterleavingString {
       // time:O(m * n) space:O(m * n)
       public boolean isInterleave(String s1, String s2, String s3) {
           if (s1.length() + s2.length() != s3.length()) return false;
           int m = s1.length();
           int n = s2.length();
           boolean[][] dp = new boolean[m + 1][n + 1];
           dp[0][0] = true;
           // init first row and col
           for (int i = 1; i <= m; i++) {
               dp[i][0] = dp[i - 1][0] && s1.charAt(i - 1) == s3.charAt(i - 1);
           }
           for (int j = 1; j <= n; j++) {
               dp[0][j] = dp[0][j - 1] && s2.charAt(j - 1) == s3.charAt(j - 1);
           }
           
           for (int i = 1; i <= m; i++) {
               for (int j = 1; j <= n; j++) {
                   int index = i + j - 1; // for s3
                   char ch = s3.charAt(index);
                   // 可能来自的两个方向。
                   // 只能写成 || 的情况
                   if (ch == s1.charAt(i - 1) || ch == s2.charAt(j - 1)) {
                       dp[i][j] = (dp[i][j - 1] && s2.charAt(j - 1) == ch) || 
                           (dp[i - 1][j] && s1.charAt(i - 1) == ch);
                   }
               }
           }
           return dp[m][n];
       }
   }
   

Py Solution
-----------

.. code-block:: py

   class Solution:
       # time: O(m * n)
       # space: O(m * n)
       def isInterleave(self, s1: str, s2: str, s3: str) -> bool:
           m, n = len(s1), len(s2)
           if m + n != len(s3):
               return False
           dp = [[False] * (n + 1) for _ in range(m + 1)]
           dp[0][0] = True
           for i in range(1, m + 1):
               if s1[i - 1] == s3[i - 1] and dp[i - 1][0]:
                   dp[i][0] = True
   
           for j in range(1, n + 1):
               if s2[j - 1] == s3[j - 1] and dp[0][j - 1]:
                   dp[0][j] = True
   
           for i in range(1, m + 1):
               for j in range(1, n + 1):
                   idx = i + j - 1
                   # s1[i-1]和s2[j-1]可能相同应该都去验证其可能性
                   if s1[i - 1] == s3[idx]:
                       dp[i][j] = dp[i][j] or dp[i - 1][j]
                   if s2[j - 1] == s3[idx]:
                       dp[i][j] = dp[i][j] or dp[i][j - 1]
   
           print(f"dp={dp}")
           return dp[m][n]
   

