===================
 212 Word Search Ii
===================

Py Solution
-----------

.. code-block:: py

   from typing import List
   from leetcode.common.py_utils import TrieNode
   
   
   class Solution:
   
       # Use Trie to avoid iterating words for the loop.
       # With Trie, we can try every position on board and keep looking based on Trie.
       # m*n*len(word)*#of word -> m*n*max(len(word))
       def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
           # backtracking and use trie to stop it earlier.
           m, n = len(board), len(board[0])
           visited = [[False] * n for _ in range(m)]
           res = []
   
           def build_trie():
               root = TrieNode()
               for word in words:
                   curr = root
                   for ch in word:
                       if ch not in curr.children:
                           curr.children[ch] = TrieNode()
                       curr = curr.children[ch]
                   curr.is_word = True
                   curr.word = word
               return root
   
           def dfs(curr, row, col):
               if row < 0 or row >= m or col < 0 or col >= n:
                   return
               if visited[row][col]:
                   return
               ch = board[row][col]
               if ch not in curr.children:
                   return
               curr = curr.children[ch]
               if curr.is_word:
                   res.append(curr.word)
                   # remove the mark since we already found this word
                   curr.is_word = False
   
               visited[row][col] = True
               dfs(curr, row, col - 1)
               dfs(curr, row, col + 1)
               dfs(curr, row - 1, col)
               dfs(curr, row + 1, col)
               visited[row][col] = False
   
           # main logic
           root = build_trie()
           for row in range(m):
               for col in range(n):
                   dfs(root, row, col)
           return res
   

Java Solution
-------------

.. code-block:: java

   package com.leetcode.trie;
   
   import java.util.ArrayList;
   import java.util.List;
   
   public class _212_WordSearchII {
   
       public class TrieNode {
           TrieNode[] child;
           boolean isWord;
           String str;
   
           public TrieNode() {
               child = new TrieNode[26];
               isWord = false;
               str = "";
           }
       }
   
       // 返回值写成了 root。。。。
       // child【index】 写错了
       public TrieNode buildTrie(String[] words) {
           TrieNode root = new TrieNode();
           for (String word : words) {
               TrieNode curr = root;
               for (int i = 0; i < word.length(); i++) {
                   int index = word.charAt(i) - 'a';
                   if (curr.child[index] == null) curr.child[index] = new TrieNode();
                   curr = curr.child[index];
               }
               curr.isWord = true;
               curr.str = word;
           }
           return root;
       }
   
       public List<String> findWords(char[][] board, String[] words) {
           // 利用words 构建trie，然后遍历baord中每一个元素 进行dfs看是否符合trie里面的，构成单词
           // m*n*len(word)*#of word -> m*n*max(len(word))
           if (board == null || board.length == 0 || board[0] == null || board[0].length == 0) return new ArrayList<>();
           if (words == null || words.length == 0) return new ArrayList<>();
   
           TrieNode root = buildTrie(words);
   
           List<String> res = new ArrayList<>();
           int m = board.length;
           int n = board[0].length;
   
           boolean[][] visited = new boolean[m][n];
           for (int i = 0; i < m; i++) {
               for (int j = 0; j < n; j++) {
                   dfs(res, root, i, j, board, visited);
               }
           }
           return res;
       }
       // [["a","a"]]
       //["aaa"] 所以需要visited数组
       public void dfs(List<String> res, TrieNode root, int i, int j, char[][] board, boolean[][] visited) {
           // 这里root查找是否有就当做了visited数组
           if (i < 0 || i >= board.length || j < 0 || j >= board[0].length) return;
           if (visited[i][j]) return;
           char ch = board[i][j];
           int index = ch - 'a';
           if (root.child[index] == null) return;
           root = root.child[index];
           // 一定需要放在取child之后：因为每次加入点的时候总是后一步。
           // [["a"]], ["a"] 
           if (root.isWord) {
               res.add(root.str);
               root.isWord = false;
           }
           visited[i][j] = true;
           dfs(res, root, i + 1, j, board, visited);
           dfs(res, root, i - 1, j, board, visited);
           dfs(res, root, i, j + 1, board, visited);
           dfs(res, root, i, j - 1, board, visited);
           visited[i][j] = false;
       }
   }
   

