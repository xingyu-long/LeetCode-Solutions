=======================
 210 Course Schedule Ii
=======================

Java Solution
-------------

.. code-block:: java

   package com.leetcode.topological_sort;
   
   
   import java.util.LinkedList;
   import java.util.Queue;
   
   public class _210_CourseScheduleII {
   
       /**
        *  210. Course Schedule II
           When: 2019/06/20
   
           solution: 思路与前面一致，但只是需要poll出来的时候保存一下
        * @param numCourses
        * @param prerequisites
        * @return
        */
       public int[] findOrder(int numCourses, int[][] prerequisites) {
           //依然使用BFS的方法 并且利用ArrayList来添加
           int[] indegree = new int[numCourses];
           int num = numCourses;
   
           for (int[] pair : prerequisites) {
               indegree[pair[0]]++;
           }
           int[] res = new int[num];
   
           Queue<Integer> queue = new LinkedList<>();
           //度为0的时候 入queue
           for (int i = 0; i < num; i++) {
               if (indegree[i] == 0) {
                   queue.offer(i);
               }
           }
           int count = 0;
           while (!queue.isEmpty()) {
               int pre = queue.poll();
               res[count++] = pre;
               for (int[] pair : prerequisites) {
                   if (pair[1] == pre) {
                       indegree[pair[0]]--;
                       if (indegree[pair[0]] == 0) {
                           queue.offer(pair[0]);
                       }
                   }
               }
           }
           // list.stream().mapToInt(i->i).toArray()
           return count == num ? res : new int[]{};
       }
   }
   

Py Solution
-----------

.. code-block:: py

   from collections import defaultdict, deque
   from typing import List
   
   
   class Solution:
       def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
           indegree = [0] * numCourses
           d = defaultdict(set)
           res = []
           queue = deque()
   
           for curr, prev in prerequisites:
               d[prev].add(curr)
               indegree[curr] += 1
           for i in range(numCourses):
               if indegree[i] == 0:
                   queue.append(i)
   
           while queue:
               size = len(queue)
               for _ in range(size):
                   curr = queue.popleft()
                   res.append(curr)
                   for nxt in d[curr]:
                       indegree[nxt] -= 1
                       if indegree[nxt] == 0:
                           queue.append(nxt)
   
           return res if len(res) == numCourses else []
   

