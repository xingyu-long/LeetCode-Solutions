==============================================================
 105 Construct Binary Tree From Preorder And Inorder Traversal
==============================================================

Py Solution
-----------

.. code-block:: py

   from typing import List, Optional
   
   from leetcode.common.py_utils import TreeNode
   
   
   class Solution:
       def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
   
           def dfs(preorder, p_start, p_end, inorder, i_start, i_end):
               if p_start > p_end or i_start > i_end:
                   return None
               curr = preorder[p_start]
               # find the split point
               split = 0
               for i in range(i_start, i_end + 1):
                   if inorder[i] == curr:
                       split = i
                       break
   
               count = split - i_start
               root = TreeNode(curr)
               root.left = dfs(
                   preorder, p_start + 1, p_start + count, inorder, i_start, split - 1
               )
               root.right = dfs(
                   preorder, p_start + 1 + count, p_end, inorder, split + 1, i_end
               )
   
               return root
   
           return dfs(preorder, 0, len(preorder) - 1, inorder, 0, len(inorder) - 1)
   
   
   class Solution:
       # easy-to-understand
       def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
           if not preorder or not inorder:
               return None
   
           root = TreeNode(preorder[0])
           mid = inorder.index(preorder[0])
           root.left = self.buildTree(preorder[1 : mid + 1], inorder[:mid])
           root.right = self.buildTree(preorder[mid + 1 :], inorder[mid + 1 :])
   
           return root
   

Java Solution
-------------

.. code-block:: java

   package com.leetcode.tree.construct;
   
   import com.leetcode.common.TreeNode;
   
   public class _105_ConstructBinaryTreefromPreorderandInorderTraversal {
       // https://www.youtube.com/watch?v=S1wNG5hx-30
       // time:O(N) space:O(N)
       public TreeNode buildTree(int[] preorder, int[] inorder) {
           return buildTree(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1);
       }
   
       public TreeNode buildTree(int[] preorder, int preStart, int preEnd, int[] inorder,
               int inStart, int inEnd) {
           if (preStart > preEnd || inStart > inEnd)
               return null;
           TreeNode root = new TreeNode(preorder[preStart]);
           // split the inorder
           int i = 0;
           for (i = inStart; i <= inEnd; i++) {
               if (inorder[i] == root.val)
                   break;
           }
           // 主要是计算长度的哪个部分。
           // preEnd = preStart + # of element - 1转为坐标。
           int len = i - inStart;
           root.left = buildTree(preorder, preStart + 1, preStart + len, inorder,
                   inStart, i - 1);
           root.right = buildTree(preorder, preStart + (1 + len), preEnd, inorder,
                   i + 1, inEnd);
           return root;
       }
   }
   
   

