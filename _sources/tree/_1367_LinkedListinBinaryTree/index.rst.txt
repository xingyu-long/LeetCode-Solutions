============================
 1367 Linkedlistinbinarytree
============================

Py Solution
-----------

.. code-block:: py

   from typing import Optional
   from leetcode.common.py_utils import TreeNode, ListNode
   
   
   class Solution:
       def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:
           if not head:
               return True
   
           if not root:
               return False
   
           def search(head, root):
               if not head:
                   return True
   
               if not root:
                   return False
   
               if head.val != root.val:
                   return False
   
               return search(head.next, root.left) or search(head.next, root.right)
   
           # start from anywhere of the tree
           return (
               search(head, root)
               or self.isSubPath(head, root.left)
               or self.isSubPath(head, root.right)
           )
   

Java Solution
-------------

.. code-block:: java

   package com.leetcode.tree;
   
   import com.leetcode.common.ListNode;
   import com.leetcode.common.TreeNode;
   
   public class _1367_LinkedListinBinaryTree {
   
       /**
        * When: 03/01/2020, 03/09/2020
        * @param head
        * @param root
        * @return
        */
       // time: O(n * min(L, H)) L: length of list, H = tree Height
       // space:O(H)
       public boolean isSubPath(ListNode head, TreeNode root) {
           if (head == null && root == null) return true;
           if (head == null || root == null) return false;
           if (head.val == root.val) {
               if (dfs(head, root))
                   return true; // 走每一个可能List开始的地方
               else
                   return isSubPath(head, root.left) || isSubPath(head, root.right);
           } else {
               return isSubPath(head, root.left) || isSubPath(head, root.right);
           }
       }
   
       public boolean dfs(ListNode head, TreeNode root) {
           if (head == null && root == null) return true;
           if (head == null && root != null) return true;
           if (head != null && root == null) return false;
           if (head.val != root.val) return false;
           boolean left = dfs(head.next, root.left);
           boolean right = dfs(head.next, root.right);
           return left || right;
       }
   }
   

