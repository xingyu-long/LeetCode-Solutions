================================================================
 2096 Step By Step Directions From A Binary Tree Node To Another
================================================================

Java Solution
-------------

.. code-block:: java

   /*
    * @Date: 07/17/2022 16:37:00
    * @LastEditTime: 07/17/2022 16:38:01
    * @Description: You need to fill out
    */
   package com.leetcode.tree;
   
   import java.util.ArrayList;
   import java.util.List;
   
   import com.leetcode.common.TreeNode;
   
   public class _2096_StepByStepDirectionsFromaBinaryTreeNodetoAnother {
       public String getDirections(TreeNode root, int startValue, int destValue) {
           // 1) Find lowest common ancestor
           TreeNode lca = getLCA(root, startValue, destValue);
           List<String> lcaToStart = new ArrayList<>();
           List<String> lcaToDest = new ArrayList<>();
           // 2) build path for start and dest value with LCA
           findPath(lca, lcaToStart, startValue);
           findPath(lca, lcaToDest, destValue);
   
           // 3) reverse to U
           for (int i = 0; i < lcaToStart.size(); i++) {
               lcaToStart.set(i, "U");
           }
   
           return String.join("", lcaToStart) + String.join("", lcaToDest);
       }
   
       public TreeNode getLCA(TreeNode root, int p, int q) {
           if (root == null || root.val == p || root.val == q) {
               return root;
           }
           TreeNode left = getLCA(root.left, p, q);
           TreeNode right = getLCA(root.right, p, q);
           if (left == null) {
               return right;
           } else if (right == null) {
               return left;
           } else {
               return root;
           }
       }
   
       public boolean findPath(TreeNode root, List<String> path, int val) {
           if (root == null)
               return false;
           if (root.val == val) {
               return true;
           }
           path.add("L");
           if (findPath(root.left, path, val))
               return true;
           path.remove(path.size() - 1);
   
           path.add("R");
           if (findPath(root.right, path, val))
               return true;
           path.remove(path.size() - 1);
   
           return false;
       }
   }
   

Py Solution
-----------

.. code-block:: py

   # Definition for a binary tree node.
   from typing import Optional
   
   
   class TreeNode:
       def __init__(self, val=0, left=None, right=None):
           self.val = val
           self.left = left
           self.right = right
   
   
   class Solution:
       def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:
   
           def find_ancestor(root, start_value, dest_value):
               if not root:
                   return None
               if root.val == start_value or root.val == dest_value:
                   return root
   
               left = find_ancestor(root.left, start_value, dest_value)
               right = find_ancestor(root.right, start_value, dest_value)
               if left and right:
                   return root
               if not left:
                   return right
               return left
   
           def find_target(root, target, path):
               if not root:
                   return False
               if root.val == target:
                   return True
   
               path.append('L')
               if find_target(root.left, target, path):
                   return True
               path.pop()
   
               path.append('R')
               if find_target(root.right, target, path):
                   return True
               path.pop()
   
               return False
   
           def reverse_path(path):
               return [('U' if d in ['L', 'R'] else d) for d in reversed(path)]
   
           ancestor = find_ancestor(root, startValue, destValue)
           left_path, right_path = [], []
           find_target(ancestor, startValue, left_path)
           find_target(ancestor, destValue, right_path)
           return ''.join(reverse_path(left_path) + right_path)
   

