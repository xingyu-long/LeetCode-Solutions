================================
 173 Binary Search Tree Iterator
================================

Java Solution
-------------

.. code-block:: java

   package com.leetcode.tree.bst;
   
   import com.leetcode.common.TreeNode;
   
   import java.util.Stack;
   /**
    * @Date: 05/13/2020
    * @Description: Tree, Inorder, Stack
    **/
   public class _173_BinarySearchTreeIterator {
   
       private Stack<TreeNode> stack;
       private TreeNode curr;
   
       public _173_BinarySearchTreeIterator(TreeNode root) {
           stack = new Stack<>();
           curr = root;
       }
   
       public int next() {
           while (curr != null) {
               stack.push(curr);
               curr = curr.left;
           }
           curr = stack.pop();
           int val = curr.val;
           curr = curr.right;
           return val;
       }
   
       public boolean hasNext() {
           return (!stack.isEmpty() || curr != null);
       }
   }
   

Py Solution
-----------

.. code-block:: py

   '''
   Date: 04/19/2022 19:54:09
   LastEditTime: 04/19/2022 19:55:27
   Description: In-order traversal
   '''
   from collections import deque
   from typing import Optional
   
   
   class TreeNode:
       def __init__(self, val=0, left=None, right=None):
           self.val = val
           self.left = left
           self.right = right
   
   
   class BSTIterator:
       def __init__(self, root: Optional[TreeNode]):
           self.deque = deque()
           self.curr = root
   
       def next(self) -> int:
           res = None
   
           while self.curr != None:
               self.deque.append(self.curr)
               self.curr = self.curr.left
           self.curr = self.deque.pop()
           res = self.curr.val
           self.curr = self.curr.right
   
           return res
   
       def hasNext(self) -> bool:
           return len(self.deque) > 0 or self.curr != None
   

