============================
 131 Palindrome Partitioning
============================

Py Solution
-----------

.. code-block:: py

   from typing import List
   
   
   class Solution:
       def partition(self, s: str) -> List[List[str]]:
           res = []
   
           def is_palindrome(s):
               left, right = 0, len(s) - 1
               while left < right:
                   if s[left] != s[right]:
                       return False
                   left += 1
                   right -= 1
               return True
   
           def dfs(path, index):
               if index == len(s):
                   res.append(list(path))
                   return
   
               for i in range(index, len(s)):
                   if is_palindrome(s[index : i + 1]):
                       path.append(s[index : i + 1])
                       dfs(path, i + 1)
                       path.pop()
   
           dfs([], 0)
           return res
   
   
   class Solution2:
       def partition(self, s: str) -> List[List[str]]:
           res = []
           dp = None
   
           def build_palindrome():
               n = len(s)
               dp = [[False] * n for _ in range(n)]
               for i in range(n):
                   for j in range(i + 1):
                       if s[i] == s[j] and (i - j <= 2 or dp[j + 1][i - 1]):
                           dp[j][i] = True
               return dp
   
           def dfs(path, index):
               nonlocal dp
   
               if index == len(s):
                   res.append(list(path))
                   return
   
               for i in range(index, len(s)):
                   if dp[index][i]:
                       path.append(s[index : i + 1])
                       dfs(path, i + 1)
                       path.pop()
   
           dp = build_palindrome()
           dfs([], 0)
           return res
   
   
   class Solution3:
       def partition(self, s: str) -> List[List[str]]:
           # dp + word break II?
           n = len(s)
           dp = [[False] * n for _ in range(n)]
           for i in range(n):
               dp[i][i] = True
               for j in range(i + 1):
                   dp[j][i] = s[j] == s[i] and (i - j <= 2 or dp[j + 1][i - 1])
   
           def dfs(idx):
               if idx == n:
                   # use it as place holder, so the upper layer call
                   # still go through `for nxt in next_words` code.
                   return [""]
   
               res = []
               for j in range(idx, n):
                   if dp[idx][j]:
                       curr = s[idx : j + 1]
                       next_words = dfs(j + 1)
                       for nxt in next_words:
                           temp = [curr]
                           temp.extend(nxt)
                           res.append(list(temp))
               return res
   
           return dfs(0)
   

Java Solution
-------------

.. code-block:: java

   /*
    * @Date: 08/11/2020 18:07:14
    * @LastEditTime: 06/16/2022 15:05:32
    * @Description: Palindrome, Backtracking
    */
   package com.leetcode.string.Palindrome;
   
   import java.util.ArrayList;
   import java.util.List;
   
   public class _131_PalindromePartitioning {
   
       // build result from begin to end;
       public List<List<String>> partition(String s) {
           if (s == null || s.length() == 0) {
               return new ArrayList<>();
           }
           int n = s.length();
           boolean[][] dp = new boolean[n][n];
           for (int i = 0; i < n; i++) {
               for (int j = 0; j <= i; j++) {
                   if (s.charAt(i) == s.charAt(j) && (i - j <= 2 || dp[j + 1][i - 1])) {
                       dp[j][i] = true;
                   }
               }
           }
           List<List<String>> res = new ArrayList<>();
           dfs(res, new ArrayList<>(), 0, s, dp);
           return res;
       }
   
       private void dfs(List<List<String>> res, List<String> list, int index, String s, boolean[][] dp) {
           if (index == s.length()) {
               res.add(new ArrayList<>(list));
               return;
           }
           for (int i = index; i < s.length(); i++) {
               if (dp[index][i]) {
                   list.add(s.substring(index, i + 1));
                   dfs(res, list, i + 1, s, dp);
                   list.remove(list.size() - 1);
               }
           }
       }
   
       // build result from end to begin.
       public List<List<String>> partition2(String s) {
           // pre-compute 
           if (s == null) return new ArrayList<>();
           int n = s.length();
           boolean[][] dp = new boolean[n][n];
           for (int j = 0; j < n; j++) {
               dp[j][j] = true;
               for (int i = 0; i < j; i++) {
                   dp[i][j] = (s.charAt(i) == s.charAt(j)) && (j - i <= 2 || dp[i + 1][j - 1]);
               }
           }
           List<List<String>> res = new ArrayList<>();
           return dfs2(s, dp, 0);
       }
       
       public List<List<String>> dfs2(String s, boolean[][] dp, int index) {
           List<List<String>> res = new ArrayList<>();
           if (index == s.length()) {
               List<String> temp = new ArrayList<>();
               res.add(new ArrayList<>(temp));
               return res;
           }
           
           for (int end = index + 1; end <= s.length(); end++) {
               if (dp[index][end - 1]) {
                   List<List<String>> next = dfs2(s, dp, end);
                   for (List<String> list : next) {
                       list.add(0, s.substring(index, end));
                       res.add(new ArrayList<>(list));
                   }
               }
           }
           return res;
       }
   }
   

