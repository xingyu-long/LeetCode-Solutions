=====================
 498 Diagonaltraverse
=====================

Java Solution
-------------

.. code-block:: java

   /*
    * @Date: 05/17/2020 11:16:20
    * @LastEditTime: 12/25/2020 10:35:08
    * @Description: traversal, Matrix
    */
   package com.leetcode.matrix;
   
   import java.util.ArrayList;
   import java.util.Collections;
   import java.util.HashMap;
   import java.util.List;
   import java.util.Map;
   
   public class _498_DiagonalTraverse {
   
       public int[] findDiagonalOrder(int[][] matrix) {
           if (matrix == null || matrix.length == 0 || matrix[0] == null || matrix[0].length == 0) {
               return new int[]{};
           }
           int m = matrix.length, n = matrix[0].length;
           int r = 0, c = 0, dir = 0;
           int[] res = new int[m * n];
           int[][] dirs = {{-1, 1}, {1, -1}}; // 右上，左下
           for (int i = 0; i < m * n; i++) {
               res[i] = matrix[r][c];
               r += dirs[dir][0];
               c += dirs[dir][1];
   
               if (r >= m) {
                   r = m - 1;
                   c += 2;
                   dir = 1 - dir;
               }
               if (c >= n) {
                   c = n - 1;
                   r += 2;
                   dir = 1 - dir;
               }
               if (r < 0) {
                   r = 0;
                   dir = 1 - dir;
               }
               if (c < 0) {
                   c = 0;
                   dir = 1 - dir;
               }
           }
           return res;
       }
   
       // 利用和的规律
       public int[] findDiagonalOrder2(int[][] matrix) {
           if (matrix == null || matrix.length == 0 || matrix[0] == null || matrix[0].length == 0) {
               return new int[]{};
           }
           int m = matrix.length, n = matrix[0].length;
           Map<Integer, List<Integer>> map = new HashMap<>();
           for (int i = 0; i < m; i++) {
               for (int j = 0; j < n; j++) {
                   int index = i + j;
                   map.putIfAbsent(index, new ArrayList<>());
                   map.get(index).add(matrix[i][j]);
               }
           }
           int[] res = new int[m * n];
           int k = 0;
           boolean flag = false;
           for (int i = 0; i <= m + n - 2; i++) {            
               List<Integer> list = map.get(i);
               if (!flag) {
                   Collections.reverse(list);
               } 
               for (int j = 0; j < list.size(); j++) {
                   res[k++] = list.get(j);
               }
               flag = !flag;
           }
           return res;
       }
   }
   

Py Solution
-----------

.. code-block:: py

   from typing import List
   from collections import defaultdict
   
   
   class Solution:
       # time: O(m*n)
       # space: O(m*n)
       def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:
           m, n = len(mat), len(mat[0])
           res = []
   
           d = defaultdict(list)
           for i in range(m):
               for j in range(n):
                   d[i + j].append(mat[i][j])
           for i in range(m + n - 1):
               data = d[i][::-1] if i % 2 == 0 else d[i]
               for item in data:
                   res.append(item)
           return res
   
   
   class Solution2:
       # time: O(m*n)
       # space: O(m*n), we don't use additional memory
       def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:
           m, n = len(mat), len(mat[0])
           # 右上，或者左下
           dirs = [[-1, 1], [1, -1]]
           row = col = 0
           curr_dir = 0
           res = [0] * (m * n)
           for i in range(m * n):
               res[i] = mat[row][col]
               row += dirs[curr_dir][0]
               col += dirs[curr_dir][1]
   
               if row >= m:
                   row = m - 1
                   col += 2
                   curr_dir = 1 - curr_dir
               if col >= n:
                   col = n - 1
                   row += 2
                   curr_dir = 1 - curr_dir
               if row < 0:
                   row = 0
                   curr_dir = 1 - curr_dir
               if col < 0:
                   col = 0
                   curr_dir = 1 - curr_dir
   
           return res
   

