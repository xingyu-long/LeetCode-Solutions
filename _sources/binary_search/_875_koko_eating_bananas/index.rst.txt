========================
 875 Koko Eating Bananas
========================

Py Solution
-----------

.. code-block:: py

   from typing import List
   
   
   class Solution:
       # time: O(logN)
       def minEatingSpeed(self, piles: List[int], h: int) -> int:
           def can_eat_all(k: int) -> bool:
               count = 0
               for p in piles:
                   count += p // k
                   if p % k != 0:
                       count += 1
               return count <= h
   
           left, right = 1, 10**9 + 1
           while left + 1 < right:
               mid = left + (right - left) // 2
               if can_eat_all(mid):
                   right = mid
               else:
                   left = mid
   
           if can_eat_all(left):
               return left
           if can_eat_all(right):
               return right
           return -1
   

Java Solution
-------------

.. code-block:: java

   package com.leetcode.binary_search;
   
   public class _875_KokoEatingBananas {
   
       /**
        * 875. Koko Eating Bananas
        * When:2019/10/24
        * Difficulty: Medium
        * @param piles
        * @param H
        * @return
        */
       // 相当于找到第一个可以满足H<=8然后最小的数
       public int minEatingSpeed(int[] piles, int H) {
           int left = 1;
           int right = (int) Math.pow(10, 9);
           while (left + 1 < right) {
               int mid = left + (right - left) / 2;
               if (canEatAll(piles, mid, H)) {
                   right = mid;
               } else {
                   left = mid;
               }
           }
           //check 哪一个更小
           if (canEatAll(piles, left, H)) return left;
           else return right;
       }
   
       public boolean canEatAll(int[] piles, int k, int H) {
           int count = 0;
           for (int pile : piles) {
               count += pile / k;
               if (pile % k != 0) count++; // 剩下的还要花一个小时完成
           }
           return count <= H;
       }
   }
   

