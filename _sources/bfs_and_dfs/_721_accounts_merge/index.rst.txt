===================
 721 Accounts Merge
===================

Py Solution
-----------

.. code-block:: py

   from collections import defaultdict
   from typing import List
   
   
   class Solution:
       def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:
           graph = defaultdict(set)
           email_to_name = {}
           for acc in accounts:
               name = acc[0]
               for i in range(1, len(acc)):
                   email = acc[i]
                   email_to_name[email] = name
                   if i == 1:
                       continue
                   prev_email = acc[i - 1]
                   graph[prev_email].add(email)
                   graph[email].add(prev_email)
   
           def dfs(email, graph, visited, path):
               if email not in visited:
                   visited.add(email)
                   path.append(email)
                   for adj in graph[email]:
                       dfs(adj, graph, visited, path)
   
           res = []
           visited = set()
           for email in email_to_name.keys():
               if email not in visited:
                   path = []
                   dfs(email, graph, visited, path)
                   path.sort()
                   path.insert(0, email_to_name[email])
                   res.append(path)
           return res
   
   
   class Solution2:
       def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:
           email_name = {}
           # union find
           parent = {}
           # parent -> set of emails
           union = defaultdict(set)
   
           def find(p, parent):
               while p != parent[p]:
                   p = parent[p]
               return p
   
           for acc in accounts:
               name = acc[0]
               for email in acc[1:]:
                   email_name[email] = name
                   parent[email] = email
   
           # union
           for acc in accounts:
               p = find(acc[1], parent)
               for email in acc[2:]:
                   parent[find(email, parent)] = p
   
           # use acc[1] as parent and add the rest of emails into this union
           for acc in accounts:
               p = find(acc[1], parent)
               for email in acc[1:]:
                   union[p].add(email)
   
           res = []
           for p in union:
               curr = sorted(list(union[p]))
               curr.insert(0, email_name[p])
               res.append(list(curr))
           return res
   

Java Solution
-------------

.. code-block:: java

   package com.leetcode.bfs_and_dfs;
   
   import java.util.*;
   
   /**
    * @Date: 05/13/2020
    * @Description: DFS, Union Find
    **/
   public class _721_AccountsMerge { 
       // time: O(# of emails)
       // space: O(# of emails)
       // 利用第一个邮箱和其他剩下的邮箱做无向图链接起来以及保持email对于name的对应
       public List<List<String>> accountsMerge(List<List<String>> accounts) {
           // 利用email来建立graph
           Map<String, Set<String>> graph = new HashMap<>();
           Map<String, String> emailToName = new HashMap<>();
           for (List<String> acc : accounts) {
               int size = acc.size();
               String name = acc.get(0);
               for (int i = 1; i < size; i++) {
                   String email = acc.get(i);
                   emailToName.put(email, name);
                   graph.putIfAbsent(email, new HashSet<>());
                   if (i == 1) {
                       continue;
                   }
                   graph.get(email).add(acc.get(i - 1));
                   graph.get(acc.get(i - 1)).add(email);
               }
           }
           List<List<String>> res = new ArrayList<>();
           Set<String> visited = new HashSet<>();
           for (String email : emailToName.keySet()) {
               List<String> list = new ArrayList<>();
               if (visited.contains(email)) continue;
               dfs(email, graph, visited, list);
               Collections.sort(list);
               list.add(0, emailToName.get(email));
               res.add(list);
           }
           return res;
       }
       
       public void dfs(String email, Map<String, Set<String>> graph, Set<String> visited, List<String> list) {
           if (visited.add(email)) {
               list.add(email);
               for (String next : graph.get(email)) {
                   dfs(next, graph, visited, list);
               }
           }
       }
   
       public List<List<String>> accountsMerge2(List<List<String>> accounts) {
           // how to merge?
           if (accounts == null || accounts.size() == 0) {
               return new ArrayList<>();
           }
           Map<String, String> emailToName = new HashMap<>();
           Map<String, String> parent = new HashMap<>();
           Map<String, TreeSet<String>> union = new HashMap<>();
           // 保留email和name的关系，并且初始化parent数组为本身。
           for (List<String> acc : accounts) {
               String name = acc.get(0);
               for (int i = 1; i < acc.size(); i++) {
                   String email = acc.get(i);
                   emailToName.put(email, name);
                   parent.put(email, email);// put themselves first
               }
           }
   
           for (List<String> acc : accounts) {
               // 设每一个的第一个点为parent节点。
               String p = find(acc.get(1), parent);
               for (int i = 2; i < acc.size(); i++) {
                   parent.put(find(acc.get(i), parent), p);
               }
           }
   
           // 需要注意这里的情况。
           for (List<String> acc : accounts) {
               // 先找到其parent节点，然后连接元素
               String p = find(acc.get(1), parent);
               if (!union.containsKey(p)) {
                   union.put(p, new TreeSet<>());
               }
               // 包括其本身也要被加入。
               for (int i = 1; i < acc.size(); i++) {
                   union.get(p).add(acc.get(i));
               }
           }
   
           List<List<String>> res = new ArrayList<>();
           for (String p : union.keySet()) {
               List<String> list = new ArrayList<>(union.get(p));
               list.add(0, emailToName.get(p));
               res.add(list);
           }
           return res;
       }
   
       public String find(String p, Map<String, String> parent) {
           while (!p.equals(parent.get(p))) {
               p = parent.get(p);
           }
           return p;
       }
   }
   

