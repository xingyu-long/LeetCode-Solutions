=====================
 253 Meeting Rooms Ii
=====================

Py Solution
-----------

.. code-block:: py

   from heapq import heappop, heappush
   from typing import List
   
   
   class Solution:
       def minMeetingRooms(self, intervals: List[List[int]]) -> int:
           """
           |     |               |
           0     5              15
                           x         x       x
                           10        20      30
           """
           if not intervals:
               return 0
           res = 0
           starts = [i[0] for i in intervals]
           ends = [i[1] for i in intervals]
           starts.sort()
           ends.sort()
           end_i = 0
           for i in range(len(starts)):
               if starts[i] < ends[end_i]:
                   res += 1
               else:
                   end_i += 1
           return res
   
   
   class Solution2:
       def minMeetingRooms(self, intervals: List[List[int]]) -> int:
           if not intervals:
               return 0
   
           intervals.sort(key=lambda x: x[0])
           heap = []
           heappush(heap, (intervals[0][1]))
           for i in range(1, len(intervals)):
               curr_end = heappop(heap)
               if intervals[i][0] < curr_end:
                   heappush(heap, (intervals[i][1]))
               else:
                   curr_end = intervals[i][1]
               heappush(heap, (curr_end))
   
           return len(heap)
   
   
   class Solution3:
       # sweep line
       def minMeetingRooms(self, intervals: List[List[int]]) -> int:
           if not intervals:
               return 0
   
           arr = []
           for start, end in intervals:
               arr.append([start, 1])
               arr.append([end, -1])
   
           # 需要把-1排到前面来。[[13,15],[1,13]]
           arr.sort(key=lambda x: (x[0], x[1]))
   
           res, count = 0, 0
           for _, op in arr:
               count += op
               res = max(res, count)
           return res
   

Java Solution
-------------

.. code-block:: java

   package com.leetcode.array.interval;
   
   import java.util.*;
   
   public class _253_MeetingRoomsII {
       /**
        * 253. Meeting Rooms II
        * When: 2019/8/3
        * review1: 11/6/2019
        * Difficulty: Medium
        */
       //  依然是使用start和end来比较
       public int minMeetingRooms2(int[][] intervals) {
           if (intervals == null || intervals.length == 0) {
               return 0;
           }
           int[] starts = new int[intervals.length];
           int[] ends = new int[intervals.length];
           for (int i = 0; i < intervals.length; i++) {
               starts[i] = intervals[i][0];
               ends[i] = intervals[i][1];
           }
           Arrays.sort(starts);
           Arrays.sort(ends);
           int res = 0;
           int end = 0;
           for (int i = 0; i < intervals.length; i++) {
               if (starts[i] < ends[end]) {
                   res++;
               } else {
                   end++;
               }
           }
           return res;
       }
   
       // 利用heap来做。相当于是有相交的话就要多个房间，然后pq以end排序，就是如果没有相交，就可以按照顺序使用。
       public int minMeetingRooms2_2(int[][] intervals) {
           if (intervals == null || intervals.length == 0) return 0;
           Arrays.sort(intervals, (a, b) -> a[0] - b[0]); // 先用开始的时间做排序
           PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);
           pq.offer(intervals[0]);
           for (int i = 1; i < intervals.length; i++) {
               int[] interval = pq.poll();
               if (intervals[i][0] >= interval[1]) { // 表明后面那个的开始大于前者的end
                   interval[1] = intervals[i][1];
               } else { // 表明有交叉
                   pq.offer(intervals[i]);
               }
               pq.offer(interval);
           }
           return pq.size();
       }
   
       // time: O(nlogn) space: O(n)
       public int minMeetingRooms_2(int[][] intervals) {
           // 计算每个时间点的人数，然后借用treemap按照发生时间排序。
           Map<Integer, Integer> map = new TreeMap<>();
           for (int[] interval : intervals) {
               map.put(interval[0], map.getOrDefault(interval[0], 0) + 1);
               map.put(interval[1], map.getOrDefault(interval[1], 0) - 1);
           }
   
           int res = 0, count = 0;
           for (int value : map.values()) {
               count += value;
               res = Math.max(res, count);
           }
           return res;
       }
   }

