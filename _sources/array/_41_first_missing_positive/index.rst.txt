==========================
 41 First Missing Positive
==========================

Py Solution
-----------

.. code-block:: py

   from typing import List
   
   """
   41. First Missing Positive
   ---
   
   Given an unsorted integer array nums. Return the smallest positive integer that is not present in nums.
   
   You must implement an algorithm that runs in O(n) time and uses O(1) auxiliary space.
   ---
   
   Example 1:
   
   Input: nums = [1,2,0]
   Output: 3
   Explanation: The numbers in the range [1,2] are all in the array.
   
   Example 2:
   
   Input: nums = [3,4,-1,1]
   Output: 2
   Explanation: 1 is in the array but 2 is missing.
   
   Example 3:
   
   Input: nums = [7,8,9,11,12]
   Output: 1
   Explanation: The smallest positive integer 1 is missing.
   """
   
   
   class Solution:
       def exch(self, nums, i, j):
           nums[i], nums[j] = nums[j], nums[i]
   
       def firstMissingPositive(self, nums: List[int]) -> int:
           """
           solution 1: sort and iterate the list
   
           solution 2:
               bucket sort? idx -> positive integer
               idx     0, 1, 2, 3, 4
               target  1, 2, 3, 4, 5
           """
           if not nums:
               return 1
           for i in range(len(nums)):
               while (
                   nums[i] - 1 >= 0
                   and nums[i] - 1 < len(nums)
                   and nums[i] != nums[nums[i] - 1]
               ):
                   self.exch(nums, i, nums[i] - 1)
   
           for i in range(len(nums)):
               if i + 1 != nums[i]:
                   return i + 1
           return len(nums) + 1
   

Java Solution
-------------

.. code-block:: java

   package com.leetcode.array;
   
   // LeetCode No. 41
   public class _41_FirstMissingPositive {
   
   
       /**
        * 13-Feb	1-Jul	6-Nov
        * 利用"桶排序"思想
        * index + 1
        * 每个位置应该满足值等于该索引+1
        * 不满足就交换 （1. 输出第一个不符合该序列的index+1 2. 整个都是符合该序列 则输出nums.length + 1）
        * @param nums
        * @return
        */
   
       //time:O(n) space:O(1)
       public static int firstMissingPositive(final int[] nums) {
           if (nums == null || nums.length == 0) return 1;
           for (int i = 0; i < nums.length; i++) {
               while (nums[i] - 1 >= 0 && nums[i] - 1 < nums.length
                       && nums[i] != nums[nums[i] - 1]) {
                   exch(nums, i, nums[i] - 1);
               }
           }
           for (int i = 0; i < nums.length; i++) {
               if (i + 1 != nums[i]) return i + 1;
           }
           return nums.length + 1;
       }
   
       public static void exch(final int[] nums, final int a, final int b) {
           final int temp = nums[a];
           nums[a] = nums[b];
           nums[b] = temp;
       }
   
   
       public static void main(final String[] args){
           System.out.println(firstMissingPositive(new int[]{3, 4, -1, 1}));
       }
   }
   

